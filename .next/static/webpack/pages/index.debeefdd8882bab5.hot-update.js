"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./context/CircuitContext.js":
/*!***********************************!*\
  !*** ./context/CircuitContext.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircuitProvider: () => (/* binding */ CircuitProvider),\n/* harmony export */   useCircuit: () => (/* binding */ useCircuit)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mathjs */ \"(pages-dir-browser)/./node_modules/mathjs/lib/esm/index.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst math = (0,mathjs__WEBPACK_IMPORTED_MODULE_2__.create)(mathjs__WEBPACK_IMPORTED_MODULE_2__.all);\nconst CircuitContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst initialState = {\n    qubits: 3,\n    circuit: Array(3).fill().map(()=>Array(5).fill(null)),\n    history: [],\n    historyIndex: -1,\n    probabilities: null\n};\nconst circuitReducer = (state, action)=>{\n    switch(action.type){\n        case 'ADD_QUBIT':\n            {\n                const newState = {\n                    qubits: state.qubits + 1,\n                    circuit: [\n                        ...state.circuit,\n                        Array(5).fill(null)\n                    ],\n                    history: state.history,\n                    historyIndex: state.historyIndex\n                };\n                return {\n                    ...newState,\n                    history: [\n                        ...state.history.slice(0, state.historyIndex + 1),\n                        {\n                            qubits: state.qubits,\n                            circuit: state.circuit\n                        }\n                    ],\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(newState.circuit, newState.qubits)\n                };\n            }\n        case 'REMOVE_QUBIT':\n            {\n                if (state.qubits <= 1) return state;\n                const newState = {\n                    qubits: state.qubits - 1,\n                    circuit: state.circuit.slice(0, -1),\n                    history: state.history,\n                    historyIndex: state.historyIndex\n                };\n                return {\n                    ...newState,\n                    history: [\n                        ...state.history.slice(0, state.historyIndex + 1),\n                        {\n                            qubits: state.qubits,\n                            circuit: state.circuit\n                        }\n                    ],\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(newState.circuit, newState.qubits)\n                };\n            }\n        case 'ADD_GATE':\n            {\n                const { qubit, time, type, targetQubit } = action.payload;\n                console.log('Adding gate:', {\n                    qubit,\n                    time,\n                    type,\n                    targetQubit\n                });\n                const newCircuit = state.circuit.map((row, i)=>i === qubit ? row.map((cell, j)=>j === time ? {\n                            type,\n                            targetQubit\n                        } : cell) : row);\n                if (type === 'CNOT' && targetQubit !== undefined) {\n                    newCircuit[targetQubit][time] = {\n                        type: 'CNOT_TARGET'\n                    };\n                }\n                const newState = {\n                    qubits: state.qubits,\n                    circuit: newCircuit,\n                    history: state.history,\n                    historyIndex: state.historyIndex\n                };\n                return {\n                    ...newState,\n                    history: [\n                        ...state.history.slice(0, state.historyIndex + 1),\n                        {\n                            qubits: state.qubits,\n                            circuit: state.circuit\n                        }\n                    ],\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(newCircuit, state.qubits)\n                };\n            }\n        case 'REMOVE_GATE':\n            {\n                const { qubit, time } = action.payload;\n                const newCircuit = state.circuit.map((row, i)=>i === qubit ? row.map((cell, j)=>j === time ? null : cell) : row);\n                const newState = {\n                    qubits: state.qubits,\n                    circuit: newCircuit,\n                    history: state.history,\n                    historyIndex: state.historyIndex\n                };\n                return {\n                    ...newState,\n                    history: [\n                        ...state.history.slice(0, state.historyIndex + 1),\n                        {\n                            qubits: state.qubits,\n                            circuit: state.circuit\n                        }\n                    ],\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(newCircuit, state.qubits)\n                };\n            }\n        case 'UPDATE_GATE':\n            {\n                const { removes, adds } = action.payload;\n                let newCircuit = state.circuit.map((row)=>[\n                        ...row\n                    ]);\n                // Apply all removals\n                removes.forEach((param)=>{\n                    let { qubit, time } = param;\n                    newCircuit = newCircuit.map((row, i)=>i === qubit ? row.map((cell, j)=>j === time ? null : cell) : row);\n                });\n                // Apply all additions\n                adds.forEach((param)=>{\n                    let { qubit, time, type, targetQubit } = param;\n                    newCircuit = newCircuit.map((row, i)=>i === qubit ? row.map((cell, j)=>j === time ? {\n                                type,\n                                targetQubit\n                            } : cell) : row);\n                    if (type === 'CNOT' && targetQubit !== undefined) {\n                        newCircuit[targetQubit][time] = {\n                            type: 'CNOT_TARGET'\n                        };\n                    }\n                });\n                const newState = {\n                    qubits: state.qubits,\n                    circuit: newCircuit,\n                    history: state.history,\n                    historyIndex: state.historyIndex\n                };\n                return {\n                    ...newState,\n                    history: [\n                        ...state.history.slice(0, state.historyIndex + 1),\n                        {\n                            qubits: state.qubits,\n                            circuit: state.circuit\n                        }\n                    ],\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(newCircuit, state.qubits)\n                };\n            }\n        case 'UNDO':\n            {\n                if (state.historyIndex <= -1) return state;\n                const prevState = state.history[state.historyIndex];\n                return {\n                    ...state,\n                    qubits: prevState.qubits,\n                    circuit: prevState.circuit,\n                    historyIndex: state.historyIndex - 1,\n                    probabilities: simulateCircuit(prevState.circuit, prevState.qubits)\n                };\n            }\n        case 'REDO':\n            {\n                if (state.historyIndex >= state.history.length - 1) return state;\n                const nextState = state.history[state.historyIndex + 1];\n                return {\n                    ...state,\n                    qubits: nextState.qubits,\n                    circuit: nextState.circuit,\n                    historyIndex: state.historyIndex + 1,\n                    probabilities: simulateCircuit(nextState.circuit, nextState.qubits)\n                };\n            }\n        default:\n            return state;\n    }\n};\nconst simulateCircuit = (circuit, qubits)=>{\n    const dim = 1 << qubits;\n    let state = math.zeros(dim, 1);\n    state.subset(math.index(0, 0), 1);\n    const H = math.matrix([\n        [\n            1 / Math.sqrt(2),\n            1 / Math.sqrt(2)\n        ],\n        [\n            1 / Math.sqrt(2),\n            -1 / Math.sqrt(2)\n        ]\n    ]);\n    const CNOT = math.matrix([\n        [\n            1,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            1,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            1\n        ],\n        [\n            0,\n            0,\n            1,\n            0\n        ]\n    ]);\n    for(let time = 0; time < circuit[0].length; time++){\n        for(let qubit = 0; qubit < qubits; qubit++){\n            const gate = circuit[qubit][time];\n            if (!gate) continue;\n            if (gate.type === 'H') {\n                const op = math.kron(math.identity(1 << qubit), math.kron(H, math.identity(1 << qubits - qubit - 1)));\n                state = math.multiply(op, state);\n            } else if (gate.type === 'CNOT') {\n                const target = gate.targetQubit;\n                if (target >= qubits) continue;\n                if (target === qubit + 1) {\n                    const op = math.kron(math.identity(1 << qubit), math.kron(CNOT, math.identity(1 << qubits - qubit - 2)));\n                    state = math.multiply(op, state);\n                }\n            }\n        }\n    }\n    const stateArray = state.toArray();\n    const probs = {};\n    for(let i = 0; i < dim; i++){\n        const basis = i.toString(2).padStart(qubits, '0');\n        probs[basis] = Math.pow(math.abs(stateArray[i][0]), 2);\n    }\n    return probs;\n};\nconst CircuitProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(circuitReducer, {\n        ...initialState,\n        probabilities: simulateCircuit(initialState.circuit, initialState.qubits)\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CircuitContext.Provider, {\n        value: {\n            state,\n            dispatch\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\elang\\\\OneDrive\\\\Desktop\\\\quantum_computing\\\\context\\\\CircuitContext.js\",\n        lineNumber: 214,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CircuitProvider, \"HQ7J8g7Wi96z+GASQZbvQjzWJ5E=\");\n_c = CircuitProvider;\nconst useCircuit = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CircuitContext);\n};\n_s1(useCircuit, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"CircuitProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbnRleHQvQ2lyY3VpdENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ3pCO0FBRXJDLE1BQU1LLE9BQU9GLDhDQUFNQSxDQUFDQyx1Q0FBR0E7QUFFdkIsTUFBTUUsK0JBQWlCTixvREFBYUE7QUFFcEMsTUFBTU8sZUFBZTtJQUNuQkMsUUFBUTtJQUNSQyxTQUFTQyxNQUFNLEdBQUdDLElBQUksR0FBR0MsR0FBRyxDQUFDLElBQU1GLE1BQU0sR0FBR0MsSUFBSSxDQUFDO0lBQ2pERSxTQUFTLEVBQUU7SUFDWEMsY0FBYyxDQUFDO0lBQ2ZDLGVBQWU7QUFDakI7QUFFQSxNQUFNQyxpQkFBaUIsQ0FBQ0MsT0FBT0M7SUFDN0IsT0FBUUEsT0FBT0MsSUFBSTtRQUNqQixLQUFLO1lBQWE7Z0JBQ2hCLE1BQU1DLFdBQVc7b0JBQ2ZaLFFBQVFTLE1BQU1ULE1BQU0sR0FBRztvQkFDdkJDLFNBQVM7MkJBQUlRLE1BQU1SLE9BQU87d0JBQUVDLE1BQU0sR0FBR0MsSUFBSSxDQUFDO3FCQUFNO29CQUNoREUsU0FBU0ksTUFBTUosT0FBTztvQkFDdEJDLGNBQWNHLE1BQU1ILFlBQVk7Z0JBQ2xDO2dCQUNBLE9BQU87b0JBQ0wsR0FBR00sUUFBUTtvQkFDWFAsU0FBUzsyQkFBSUksTUFBTUosT0FBTyxDQUFDUSxLQUFLLENBQUMsR0FBR0osTUFBTUgsWUFBWSxHQUFHO3dCQUFJOzRCQUFFTixRQUFRUyxNQUFNVCxNQUFNOzRCQUFFQyxTQUFTUSxNQUFNUixPQUFPO3dCQUFDO3FCQUFFO29CQUM5R0ssY0FBY0csTUFBTUgsWUFBWSxHQUFHO29CQUNuQ0MsZUFBZU8sZ0JBQWdCRixTQUFTWCxPQUFPLEVBQUVXLFNBQVNaLE1BQU07Z0JBQ2xFO1lBQ0Y7UUFDQSxLQUFLO1lBQWdCO2dCQUNuQixJQUFJUyxNQUFNVCxNQUFNLElBQUksR0FBRyxPQUFPUztnQkFDOUIsTUFBTUcsV0FBVztvQkFDZlosUUFBUVMs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NUMsS0FBS2dELFFBQVEsQ0FBQyxLQUFNN0MsU0FBU2UsUUFBUTtvQkFFdkROLFFBQVFaLEtBQUtpRCxRQUFRLENBQUNILElBQUlsQztnQkFDNUI7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNdUMsYUFBYXZDLE1BQU13QyxPQUFPO0lBQ2hDLE1BQU1DLFFBQVEsQ0FBQztJQUNmLElBQUssSUFBSTNCLElBQUksR0FBR0EsSUFBSVUsS0FBS1YsSUFBSztRQUM1QixNQUFNNEIsUUFBUTVCLEVBQUU2QixRQUFRLENBQUMsR0FBR0MsUUFBUSxDQUFDckQsUUFBUTtRQUM3Q2tELEtBQUssQ0FBQ0MsTUFBTSxHQUFHWixLQUFLZSxHQUFHLENBQUN6RCxLQUFLMEQsR0FBRyxDQUFDUCxVQUFVLENBQUN6QixFQUFFLENBQUMsRUFBRSxHQUFHO0lBQ3REO0lBQ0EsT0FBTzJCO0FBQ1Q7QUFFTyxNQUFNTSxrQkFBa0I7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQzFDLE1BQU0sQ0FBQ2hELE9BQU9pRCxTQUFTLEdBQUdoRSxpREFBVUEsQ0FBQ2MsZ0JBQWdCO1FBQ25ELEdBQUdULFlBQVk7UUFDZlEsZUFBZU8sZ0JBQWdCZixhQUFhRSxPQUFPLEVBQUVGLGFBQWFDLE1BQU07SUFDMUU7SUFDQSxxQkFDRSw4REFBQ0YsZUFBZTZELFFBQVE7UUFBQ0MsT0FBTztZQUFFbkQ7WUFBT2lEO1FBQVM7a0JBQy9DRDs7Ozs7O0FBR1AsRUFBRTtHQVZXRDtLQUFBQTtBQVlOLE1BQU1LLGFBQWE7O0lBQU1wRSxPQUFBQSxpREFBVUEsQ0FBQ0s7QUFBYyxFQUFFO0lBQTlDK0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZWxhbmdcXE9uZURyaXZlXFxEZXNrdG9wXFxxdWFudHVtX2NvbXB1dGluZ1xcY29udGV4dFxcQ2lyY3VpdENvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgY3JlYXRlLCBhbGwgfSBmcm9tICdtYXRoanMnO1xyXG5cclxuY29uc3QgbWF0aCA9IGNyZWF0ZShhbGwpO1xyXG5cclxuY29uc3QgQ2lyY3VpdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgcXViaXRzOiAzLFxyXG4gIGNpcmN1aXQ6IEFycmF5KDMpLmZpbGwoKS5tYXAoKCkgPT4gQXJyYXkoNSkuZmlsbChudWxsKSksXHJcbiAgaGlzdG9yeTogW10sXHJcbiAgaGlzdG9yeUluZGV4OiAtMSxcclxuICBwcm9iYWJpbGl0aWVzOiBudWxsLFxyXG59O1xyXG5cclxuY29uc3QgY2lyY3VpdFJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgIGNhc2UgJ0FERF9RVUJJVCc6IHtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAgICAgcXViaXRzOiBzdGF0ZS5xdWJpdHMgKyAxLFxyXG4gICAgICAgIGNpcmN1aXQ6IFsuLi5zdGF0ZS5jaXJjdWl0LCBBcnJheSg1KS5maWxsKG51bGwpXSxcclxuICAgICAgICBoaXN0b3J5OiBzdGF0ZS5oaXN0b3J5LFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4LFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLm5ld1N0YXRlLFxyXG4gICAgICAgIGhpc3Rvcnk6IFsuLi5zdGF0ZS5oaXN0b3J5LnNsaWNlKDAsIHN0YXRlLmhpc3RvcnlJbmRleCArIDEpLCB7IHF1Yml0czogc3RhdGUucXViaXRzLCBjaXJjdWl0OiBzdGF0ZS5jaXJjdWl0IH1dLFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4ICsgMSxcclxuICAgICAgICBwcm9iYWJpbGl0aWVzOiBzaW11bGF0ZUNpcmN1aXQobmV3U3RhdGUuY2lyY3VpdCwgbmV3U3RhdGUucXViaXRzKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgJ1JFTU9WRV9RVUJJVCc6IHtcclxuICAgICAgaWYgKHN0YXRlLnF1Yml0cyA8PSAxKSByZXR1cm4gc3RhdGU7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xyXG4gICAgICAgIHF1Yml0czogc3RhdGUucXViaXRzIC0gMSxcclxuICAgICAgICBjaXJjdWl0OiBzdGF0ZS5jaXJjdWl0LnNsaWNlKDAsIC0xKSxcclxuICAgICAgICBoaXN0b3J5OiBzdGF0ZS5oaXN0b3J5LFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4LFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLm5ld1N0YXRlLFxyXG4gICAgICAgIGhpc3Rvcnk6IFsuLi5zdGF0ZS5oaXN0b3J5LnNsaWNlKDAsIHN0YXRlLmhpc3RvcnlJbmRleCArIDEpLCB7IHF1Yml0czogc3RhdGUucXViaXRzLCBjaXJjdWl0OiBzdGF0ZS5jaXJjdWl0IH1dLFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4ICsgMSxcclxuICAgICAgICBwcm9iYWJpbGl0aWVzOiBzaW11bGF0ZUNpcmN1aXQobmV3U3RhdGUuY2lyY3VpdCwgbmV3U3RhdGUucXViaXRzKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgJ0FERF9HQVRFJzoge1xyXG4gICAgICBjb25zdCB7IHF1Yml0LCB0aW1lLCB0eXBlLCB0YXJnZXRRdWJpdCB9ID0gYWN0aW9uLnBheWxvYWQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgZ2F0ZTonLCB7IHF1Yml0LCB0aW1lLCB0eXBlLCB0YXJnZXRRdWJpdCB9KTtcclxuICAgICAgY29uc3QgbmV3Q2lyY3VpdCA9IHN0YXRlLmNpcmN1aXQubWFwKChyb3csIGkpID0+XHJcbiAgICAgICAgaSA9PT0gcXViaXRcclxuICAgICAgICAgID8gcm93Lm1hcCgoY2VsbCwgaikgPT4gKGogPT09IHRpbWUgPyB7IHR5cGUsIHRhcmdldFF1Yml0IH0gOiBjZWxsKSlcclxuICAgICAgICAgIDogcm93XHJcbiAgICAgICk7XHJcbiAgICAgIGlmICh0eXBlID09PSAnQ05PVCcgJiYgdGFyZ2V0UXViaXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5ld0NpcmN1aXRbdGFyZ2V0UXViaXRdW3RpbWVdID0geyB0eXBlOiAnQ05PVF9UQVJHRVQnIH07XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAgICAgcXViaXRzOiBzdGF0ZS5xdWJpdHMsXHJcbiAgICAgICAgY2lyY3VpdDogbmV3Q2lyY3VpdCxcclxuICAgICAgICBoaXN0b3J5OiBzdGF0ZS5oaXN0b3J5LFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4LFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLm5ld1N0YXRlLFxyXG4gICAgICAgIGhpc3Rvcnk6IFsuLi5zdGF0ZS5oaXN0b3J5LnNsaWNlKDAsIHN0YXRlLmhpc3RvcnlJbmRleCArIDEpLCB7IHF1Yml0czogc3RhdGUucXViaXRzLCBjaXJjdWl0OiBzdGF0ZS5jaXJjdWl0IH1dLFxyXG4gICAgICAgIGhpc3RvcnlJbmRleDogc3RhdGUuaGlzdG9yeUluZGV4ICsgMSxcclxuICAgICAgICBwcm9iYWJpbGl0aWVzOiBzaW11bGF0ZUNpcmN1aXQobmV3Q2lyY3VpdCwgc3RhdGUucXViaXRzKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgJ1JFTU9WRV9HQVRFJzoge1xyXG4gICAgICBjb25zdCB7IHF1Yml0LCB0aW1lIH0gPSBhY3Rpb24ucGF5bG9hZDtcclxuICAgICAgY29uc3QgbmV3Q2lyY3VpdCA9IHN0YXRlLmNpcmN1aXQubWFwKChyb3csIGkpID0+XHJcbiAgICAgICAgaSA9PT0gcXViaXRcclxuICAgICAgICAgID8gcm93Lm1hcCgoY2VsbCwgaikgPT4gKGogPT09IHRpbWUgPyBudWxsIDogY2VsbCkpXHJcbiAgICAgICAgICA6IHJvd1xyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgICAgICBxdWJpdHM6IHN0YXRlLnF1Yml0cyxcclxuICAgICAgICBjaXJjdWl0OiBuZXdDaXJjdWl0LFxyXG4gICAgICAgIGhpc3Rvcnk6IHN0YXRlLmhpc3RvcnksXHJcbiAgICAgICAgaGlzdG9yeUluZGV4OiBzdGF0ZS5oaXN0b3J5SW5kZXgsXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ubmV3U3RhdGUsXHJcbiAgICAgICAgaGlzdG9yeTogWy4uLnN0YXRlLmhpc3Rvcnkuc2xpY2UoMCwgc3RhdGUuaGlzdG9yeUluZGV4ICsgMSksIHsgcXViaXRzOiBzdGF0ZS5xdWJpdHMsIGNpcmN1aXQ6IHN0YXRlLmNpcmN1aXQgfV0sXHJcbiAgICAgICAgaGlzdG9yeUluZGV4OiBzdGF0ZS5oaXN0b3J5SW5kZXggKyAxLFxyXG4gICAgICAgIHByb2JhYmlsaXRpZXM6IHNpbXVsYXRlQ2lyY3VpdChuZXdDaXJjdWl0LCBzdGF0ZS5xdWJpdHMpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSAnVVBEQVRFX0dBVEUnOiB7XHJcbiAgICAgIGNvbnN0IHsgcmVtb3ZlcywgYWRkcyB9ID0gYWN0aW9uLnBheWxvYWQ7XHJcbiAgICAgIGxldCBuZXdDaXJjdWl0ID0gc3RhdGUuY2lyY3VpdC5tYXAocm93ID0+IFsuLi5yb3ddKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IGFsbCByZW1vdmFsc1xyXG4gICAgICByZW1vdmVzLmZvckVhY2goKHsgcXViaXQsIHRpbWUgfSkgPT4ge1xyXG4gICAgICAgIG5ld0NpcmN1aXQgPSBuZXdDaXJjdWl0Lm1hcCgocm93LCBpKSA9PlxyXG4gICAgICAgICAgaSA9PT0gcXViaXRcclxuICAgICAgICAgICAgPyByb3cubWFwKChjZWxsLCBqKSA9PiAoaiA9PT0gdGltZSA/IG51bGwgOiBjZWxsKSlcclxuICAgICAgICAgICAgOiByb3dcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IGFsbCBhZGRpdGlvbnNcclxuICAgICAgYWRkcy5mb3JFYWNoKCh7IHF1Yml0LCB0aW1lLCB0eXBlLCB0YXJnZXRRdWJpdCB9KSA9PiB7XHJcbiAgICAgICAgbmV3Q2lyY3VpdCA9IG5ld0NpcmN1aXQubWFwKChyb3csIGkpID0+XHJcbiAgICAgICAgICBpID09PSBxdWJpdFxyXG4gICAgICAgICAgICA/IHJvdy5tYXAoKGNlbGwsIGopID0+IChqID09PSB0aW1lID8geyB0eXBlLCB0YXJnZXRRdWJpdCB9IDogY2VsbCkpXHJcbiAgICAgICAgICAgIDogcm93XHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ0NOT1QnICYmIHRhcmdldFF1Yml0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5ld0NpcmN1aXRbdGFyZ2V0UXViaXRdW3RpbWVdID0geyB0eXBlOiAnQ05PVF9UQVJHRVQnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xyXG4gICAgICAgIHF1Yml0czogc3RhdGUucXViaXRzLFxyXG4gICAgICAgIGNpcmN1aXQ6IG5ld0NpcmN1aXQsXHJcbiAgICAgICAgaGlzdG9yeTogc3RhdGUuaGlzdG9yeSxcclxuICAgICAgICBoaXN0b3J5SW5kZXg6IHN0YXRlLmhpc3RvcnlJbmRleCxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5uZXdTdGF0ZSxcclxuICAgICAgICBoaXN0b3J5OiBbLi4uc3RhdGUuaGlzdG9yeS5zbGljZSgwLCBzdGF0ZS5oaXN0b3J5SW5kZXggKyAxKSwgeyBxdWJpdHM6IHN0YXRlLnF1Yml0cywgY2lyY3VpdDogc3RhdGUuY2lyY3VpdCB9XSxcclxuICAgICAgICBoaXN0b3J5SW5kZXg6IHN0YXRlLmhpc3RvcnlJbmRleCArIDEsXHJcbiAgICAgICAgcHJvYmFiaWxpdGllczogc2ltdWxhdGVDaXJjdWl0KG5ld0NpcmN1aXQsIHN0YXRlLnF1Yml0cyksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlICdVTkRPJzoge1xyXG4gICAgICBpZiAoc3RhdGUuaGlzdG9yeUluZGV4IDw9IC0xKSByZXR1cm4gc3RhdGU7XHJcbiAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHN0YXRlLmhpc3Rvcnlbc3RhdGUuaGlzdG9yeUluZGV4XTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBxdWJpdHM6IHByZXZTdGF0ZS5xdWJpdHMsXHJcbiAgICAgICAgY2lyY3VpdDogcHJldlN0YXRlLmNpcmN1aXQsXHJcbiAgICAgICAgaGlzdG9yeUluZGV4OiBzdGF0ZS5oaXN0b3J5SW5kZXggLSAxLFxyXG4gICAgICAgIHByb2JhYmlsaXRpZXM6IHNpbXVsYXRlQ2lyY3VpdChwcmV2U3RhdGUuY2lyY3VpdCwgcHJldlN0YXRlLnF1Yml0cyksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlICdSRURPJzoge1xyXG4gICAgICBpZiAoc3RhdGUuaGlzdG9yeUluZGV4ID49IHN0YXRlLmhpc3RvcnkubGVuZ3RoIC0gMSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5oaXN0b3J5W3N0YXRlLmhpc3RvcnlJbmRleCArIDFdO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRlLFxyXG4gICAgICAgIHF1Yml0czogbmV4dFN0YXRlLnF1Yml0cyxcclxuICAgICAgICBjaXJjdWl0OiBuZXh0U3RhdGUuY2lyY3VpdCxcclxuICAgICAgICBoaXN0b3J5SW5kZXg6IHN0YXRlLmhpc3RvcnlJbmRleCArIDEsXHJcbiAgICAgICAgcHJvYmFiaWxpdGllczogc2ltdWxhdGVDaXJjdWl0KG5leHRTdGF0ZS5jaXJjdWl0LCBuZXh0U3RhdGUucXViaXRzKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBzaW11bGF0ZUNpcmN1aXQgPSAoY2lyY3VpdCwgcXViaXRzKSA9PiB7XHJcbiAgY29uc3QgZGltID0gMSA8PCBxdWJpdHM7XHJcbiAgbGV0IHN0YXRlID0gbWF0aC56ZXJvcyhkaW0sIDEpO1xyXG4gIHN0YXRlLnN1YnNldChtYXRoLmluZGV4KDAsIDApLCAxKTtcclxuXHJcbiAgY29uc3QgSCA9IG1hdGgubWF0cml4KFtcclxuICAgIFsxIC8gTWF0aC5zcXJ0KDIpLCAxIC8gTWF0aC5zcXJ0KDIpXSxcclxuICAgIFsxIC8gTWF0aC5zcXJ0KDIpLCAtMSAvIE1hdGguc3FydCgyKV0sXHJcbiAgXSk7XHJcblxyXG4gIGNvbnN0IENOT1QgPSBtYXRoLm1hdHJpeChbXHJcbiAgICBbMSwgMCwgMCwgMF0sXHJcbiAgICBbMCwgMSwgMCwgMF0sXHJcbiAgICBbMCwgMCwgMCwgMV0sXHJcbiAgICBbMCwgMCwgMSwgMF0sXHJcbiAgXSk7XHJcblxyXG4gIGZvciAobGV0IHRpbWUgPSAwOyB0aW1lIDwgY2lyY3VpdFswXS5sZW5ndGg7IHRpbWUrKykge1xyXG4gICAgZm9yIChsZXQgcXViaXQgPSAwOyBxdWJpdCA8IHF1Yml0czsgcXViaXQrKykge1xyXG4gICAgICBjb25zdCBnYXRlID0gY2lyY3VpdFtxdWJpdF1bdGltZV07XHJcbiAgICAgIGlmICghZ2F0ZSkgY29udGludWU7XHJcblxyXG4gICAgICBpZiAoZ2F0ZS50eXBlID09PSAnSCcpIHtcclxuICAgICAgICBjb25zdCBvcCA9IG1hdGgua3JvbihcclxuICAgICAgICAgIG1hdGguaWRlbnRpdHkoMSA8PCBxdWJpdCksXHJcbiAgICAgICAgICBtYXRoLmtyb24oSCwgbWF0aC5pZGVudGl0eSgxIDw8IChxdWJpdHMgLSBxdWJpdCAtIDEpKSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHN0YXRlID0gbWF0aC5tdWx0aXBseShvcCwgc3RhdGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdhdGUudHlwZSA9PT0gJ0NOT1QnKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2F0ZS50YXJnZXRRdWJpdDtcclxuICAgICAgICBpZiAodGFyZ2V0ID49IHF1Yml0cykgY29udGludWU7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHF1Yml0ICsgMSkge1xyXG4gICAgICAgICAgY29uc3Qgb3AgPSBtYXRoLmtyb24oXHJcbiAgICAgICAgICAgIG1hdGguaWRlbnRpdHkoMSA8PCBxdWJpdCksXHJcbiAgICAgICAgICAgIG1hdGgua3JvbihDTk9ULCBtYXRoLmlkZW50aXR5KDEgPDwgKHF1Yml0cyAtIHF1Yml0IC0gMikpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHN0YXRlID0gbWF0aC5tdWx0aXBseShvcCwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhdGVBcnJheSA9IHN0YXRlLnRvQXJyYXkoKTtcclxuICBjb25zdCBwcm9icyA9IHt9O1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltOyBpKyspIHtcclxuICAgIGNvbnN0IGJhc2lzID0gaS50b1N0cmluZygyKS5wYWRTdGFydChxdWJpdHMsICcwJyk7XHJcbiAgICBwcm9ic1tiYXNpc10gPSBNYXRoLnBvdyhtYXRoLmFicyhzdGF0ZUFycmF5W2ldWzBdKSwgMik7XHJcbiAgfVxyXG4gIHJldHVybiBwcm9icztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBDaXJjdWl0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyKGNpcmN1aXRSZWR1Y2VyLCB7XHJcbiAgICAuLi5pbml0aWFsU3RhdGUsXHJcbiAgICBwcm9iYWJpbGl0aWVzOiBzaW11bGF0ZUNpcmN1aXQoaW5pdGlhbFN0YXRlLmNpcmN1aXQsIGluaXRpYWxTdGF0ZS5xdWJpdHMpLFxyXG4gIH0pO1xyXG4gIHJldHVybiAoXHJcbiAgICA8Q2lyY3VpdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgc3RhdGUsIGRpc3BhdGNoIH19PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0NpcmN1aXRDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQ2lyY3VpdCA9ICgpID0+IHVzZUNvbnRleHQoQ2lyY3VpdENvbnRleHQpOyJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZHVjZXIiLCJjcmVhdGUiLCJhbGwiLCJtYXRoIiwiQ2lyY3VpdENvbnRleHQiLCJpbml0aWFsU3RhdGUiLCJxdWJpdHMiLCJjaXJjdWl0IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiaGlzdG9yeSIsImhpc3RvcnlJbmRleCIsInByb2JhYmlsaXRpZXMiLCJjaXJjdWl0UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5ld1N0YXRlIiwic2xpY2UiLCJzaW11bGF0ZUNpcmN1aXQiLCJxdWJpdCIsInRpbWUiLCJ0YXJnZXRRdWJpdCIsInBheWxvYWQiLCJjb25zb2xlIiwibG9nIiwibmV3Q2lyY3VpdCIsInJvdyIsImkiLCJjZWxsIiwiaiIsInVuZGVmaW5lZCIsInJlbW92ZXMiLCJhZGRzIiwiZm9yRWFjaCIsInByZXZTdGF0ZSIsImxlbmd0aCIsIm5leHRTdGF0ZSIsImRpbSIsInplcm9zIiwic3Vic2V0IiwiaW5kZXgiLCJIIiwibWF0cml4IiwiTWF0aCIsInNxcnQiLCJDTk9UIiwiZ2F0ZSIsIm9wIiwia3JvbiIsImlkZW50aXR5IiwibXVsdGlwbHkiLCJ0YXJnZXQiLCJzdGF0ZUFycmF5IiwidG9BcnJheSIsInByb2JzIiwiYmFzaXMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicG93IiwiYWJzIiwiQ2lyY3VpdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkaXNwYXRjaCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VDaXJjdWl0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./context/CircuitContext.js\n"));

/***/ })

});